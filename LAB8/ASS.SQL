-- 1A
CREATE OR REPLACE FUNCTION INCREMENT(VALUE INTEGER)
RETURNS INTEGER AS
$$
BEGIN
    RETURN VALUE + 1;
END;
$$
    LANGUAGE plpgsql;

SELECT INCREMENT(INCREMENT(5));

-- 1B
CREATE OR REPLACE FUNCTION CUBE(INOUT A INTEGER)
AS
    $$
    BEGIN
        A:= A*A*A;
    end;
$$
    LANGUAGE plpgsql;

SELECT CUBE(5);

-- 1C
CREATE OR REPLACE FUNCTION GET_SUM(A INTEGER, B INTEGER)
RETURNS INTEGER AS
    $$
    BEGIN
        RETURN A + B;
    end;
$$
    LANGUAGE PLPGSQL;

SELECT GET_SUM(7, 4);

-- 1D
CREATE OR REPLACE FUNCTION EVEN_OR_ODD(A INTEGER)
RETURNS BOOL AS
    $$
    DECLARE
        N INTEGER;
    BEGIN
        N = MOD(A, 2);
        RETURN CASE
            WHEN N = 0 THEN TRUE
                ELSE FALSE
            END;
    END;
    $$
LANGUAGE PLPGSQL;

SELECT EVEN_OR_ODD(5);
DROP FUNCTION EVEN_OR_ODD;

-- 1E
CREATE OR REPLACE FUNCTION SUM_M(VARIADIC LIST NUMERIC[],
OUT TOTAL NUMERIC) AS
    $$
BEGIN
    SELECT INTO TOTAL SUM(LIST[I])
    FROM GENERATE_SUBSCRIPTS(LIST, 1) G(I);
END;
$$
LANGUAGE PLPGSQL;

SELECT SUM_M(5, 6, 7, 2, 7, 89, 549);

-- 1F
CREATE OR REPLACE FUNCTION CNT(VARIADIC LIST NUMERIC[], OUT COUNTER NUMERIC)
AS
$$
BEGIN
    SELECT INTO COUNTER COUNT(*)
    FROM GENERATE_SUBSCRIPTS(LIST, 1) G(I);
end;
$$
LANGUAGE PLPGSQL;

SELECT CNT(4, 7, 8, 5, 6);

-- 1G
CREATE OR REPLACE FUNCTION CHECKK(S VARCHAR)
    RETURNS BOOL
AS
    $$
    DECLARE
        PASSWORD VARCHAR := 'QWE';
    BEGIN
        RETURN CASE
        WHEN S = PASSWORD THEN TRUE
        ELSE FALSE
        END;
end;
$$
LANGUAGE PLPGSQL;

SELECT CHECKK('QW');

-- 1H
CREATE OR REPLACE FUNCTION INOUTS(IN A INTEGER, OUT X INTEGER, OUT Y INTEGER)
AS
    $$
BEGIN
    X := A * 2;
    Y := A * 4;
END;
$$
LANGUAGE plpgsql;

SELECT INOUTS(2);

-- 2A
CREATE TABLE IF NOT EXISTS CHPOX
(
    CITY VARCHAR,
    CURRENT__TIME TIMESTAMP,
    UPDATED_TIME TIMESTAMP
);

INSERT INTO CHPOX(CITY, CURRENT__TIME)
VALUES('SHYMKENT', CURRENT_TIMESTAMP);

CREATE OR REPLACE FUNCTION UPDATEE()
RETURNS TRIGGER AS
    $$
    DECLARE
        TIME TIMESTAMP;
    BEGIN
        TIME = CURRENT_TIMESTAMP;
        NEW.UPDATED_TIME = TIME;
        RETURN NEW;
    END;
    $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER UPDATETRIGGER
    BEFORE UPDATE
    ON CHPOX
    FOR EACH ROW
    EXECUTE PROCEDURE UPDATEE();

SELECT * FROM CHPOX;

UPDATE CHPOX
SET CITY = 'ALMATY'
WHERE CITY = 'SHYMKENT';

SELECT * FROM CHPOX;


-- 2B
CREATE TABLE IF NOT EXISTS BIRTH
(
    NAME VARCHAR,
    AGE INT,
    YEAR INT
);

CREATE OR REPLACE FUNCTION ZZZ()
RETURNS TRIGGER AS
    $$
    DECLARE
        Y INT;
    BEGIN
        Y = 2022 - NEW.YEAR;
        NEW.AGE = Y;
        RETURN NEW;
end;
$$
LANGUAGE PLPGSQL;



CREATE OR REPLACE TRIGGER AGETRIGGER
    BEFORE INSERT
    ON BIRTH
    FOR EACH ROW
    EXECUTE PROCEDURE ZZZ();

INSERT INTO BIRTH(NAME, YEAR)
VALUES('DIDAR', 2003);

SELECT * FROM BIRTH;

-- 2C
CREATE TABLE IF NOT EXISTS TAX
(
    PRICE REAL,
    TOTAL_PRICE REAL
);

CREATE OR REPLACE FUNCTION ADD()
RETURNS TRIGGER AS
    $$
    BEGIN
        NEW.TOTAL_PRICE = NEW.PRICE + NEW.PRICE * 0.12;
        RETURN NEW;
end;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER INCREASE
    BEFORE INSERT
    ON TAX
    FOR EACH ROW
    EXECUTE PROCEDURE ADD();

INSERT INTO TAX(PRICE) VALUES(5200);

SELECT * FROM TAX;

-- 2D
CREATE OR REPLACE FUNCTION DEL()
RETURNS TRIGGER AS
    $$
    BEGIN
        IF OLD.NAME = 'DIDAR' THEN
            RAISE EXCEPTION 'CANNOT BE DELETED';
        end if;
    end
    $$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER DEL_TRIGGER
    BEFORE DELETE
    ON BIRTH
    FOR EACH ROW
    EXECUTE PROCEDURE DEL();

DELETE FROM BIRTH
WHERE NAME = 'DIDAR';


-- 2E

CREATE TABLE IF NOT EXISTS WORKERS
(
    ID INT,
    NAME VARCHAR(20),
    AGE INTEGER,
    LIST NUMERIC[],
    TOTAL NUMERIC,
    POS BOOL
);

create OR REPLACE function launch_d_e()
    returns trigger as
    $$
    begin
        NEW.TOTAL = SUM_M(new.LIST);
        NEW.POS = EVEN_OR_ODD(new.age);
        return new;
    end;
    $$
LANGUAGE PLPGSQL;


create OR REPLACE trigger launch_functions_trigger
    after insert on workers
    for each row
execute PROCEDURE launch_d_e();

insert into workers(id, name, age, LIST) values(2, 'Alex', 48, ARRAY[48, 5, 6, 6, 7]);

SELECT * FROM WORKERS;


-- 3A
CREATE TABLE IF NOT EXISTS EMPLOYEE
(
    ID INTEGER,
    NAME VARCHAR,
    DATE_OF_BIRTH DATE,
    AGE INTEGER,
    SALARY INTEGER,
    WORK_EXPERIENCE INTEGER,
    DISCOUNT INTEGER
);

insert into employee
    (id, name, date_of_birth, age, salaRy, work_experiEnce, discount)
values
    (1, 'Dias', '1980-12-02', 42, 150000, 9, 5),
    (201, 'Didar', '1996-12-02', 26, 155000, 2, 3);

SELECT * FROM EMPLOYEE;


CREATE OR REPLACE FUNCTION HARD()
RETURNS TRIGGER AS
    $$
    DECLARE
        YEAR INTEGER;
    BEGIN
        YEAR = NEW.WORK_EXPERIENCE - OLD.WORK_EXPERIENCE;
        IF YEAR <= 0 THEN
            NEW.SALARY = OLD.SALARY;
            NEW.DISCOUNT = OLD.DISCOUNT;
        ELSIF MOD(YEAR, 2) = 0 THEN
            NEW.SALARY = (OLD.SALARY + OLD.SALARY * 0.1) * (YEAR/2);
            NEW.DISCOUNT = (OLD.DISCOUNT + OLD.DISCOUNT * 0.1) * (YEAR/2);
        ELSIF MOD(YEAR, 5) = 0 THEN
            NEW.DISCOUNT = (OLD.DISCOUNT + OLD.DISCOUNT*0.01) * (YEAR/5);
        ELSE
            NEW.SALARY = OLD.SALARY;
            NEW.DISCOUNT = OLD.DISCOUNT;
        end if;
        RETURN NEW;
end;
$$
LANGUAGE PLPGSQL;

CREATE OR REPLACE TRIGGER HARD_TRIGGER
    BEFORE UPDATE
    ON EMPLOYEE
    FOR EACH ROW
    EXECUTE PROCEDURE HARD();

UPDATE EMPLOYEE
SET WORK_EXPERIENCE = 20
WHERE ID = 1;

-- 3B
CREATE OR REPLACE FUNCTION HARD_TO()
RETURNS TRIGGER AS
    $$
    DECLARE
        YEAR INTEGER;
    BEGIN
        YEAR = NEW.WORK_EXPERIENCE - OLD.WORK_EXPERIENCE;
        IF OLD.AGE = 40 OR NEW.AGE = 40 THEN
            NEW.SALARY = OLD.SALARY + OLD.SALARY*0.15;
        end if;
        IF YEAR > 8 THEN
            NEW.SALARY = (OLD.SALARY + OLD.SALARY*0.15) * YEAR;
            NEW.DISCOUNT = (OLD.DISCOUNT + OLD.DISCOUNT*0.2);
        end if;
        RETURN NEW;
    END;
    $$
LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER HARD_TO_TRIGGER
    BEFORE UPDATE
    ON EMPLOYEE
    FOR EACH ROW
    EXECUTE PROCEDURE HARD_TO();

UPDATE EMPLOYEE
SET AGE = 40
WHERE ID = 1;
